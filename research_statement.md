# Research Statement

## Current Challenges for Robotics Research Software

The **increasing complexity and the integration challenges** of modern robots, in particular **humanoid robots**, means that no single person is able to develop or even know the details of every aspect of a robotic system, even just from a **software or firmware point of view**. This means that the basic building blocks of software should be **transparently composable**~\citeother{Vanthienen2014} to be effectively re-used in projects of **increasing complexity** and in which developers of different backgrounds contribute, especially in a research context. 
Furthermore, the modern applications of **artificial intelligence (AI) and co-design techniques** means that it is important that research software is **reusable in different contexts**, to permit to use the software developed to control a robot not only on a real robot, but also to efficiently train \textbf{AI predictive models} in massively parallel simulations or to use  **software-hardware co-design**~\citeother{ramos2018codesign} to design new version of the robots that are fully optimized with respect to the capabilities required by the control software. 
More in particular, I think that the **current and future challenges** that **research robotics software** needs to face can be summarized in the following four areas: 

* **C1: Software Reusability and Composability**: The robotics software stack necessary to operate a humanoid robot is composed by different software components, such as **joint controllers** running on **embedded boards**, **whole-body controllers for walking and manipulation and vision-based navigation** running on **on-board computers**, and **high level artificial intelligence planners** running on **remote servers in the cloud**. All these **software components** are developed by domain experts using with different \textbf{tools and programming languages}, however it is necessary to be able to easily run software developed for one domain in the tools of another domain. Furthermore, the software does not need anymore to just run in the simulation environment in which it is developed and on the real robot, but also on different simulation environments such as \textbf{Computer-aided design (CAD)} for co-design efforts or \textbf{specialized simulators for AI training}.
* **C2: Distributed and Heterogenous Architectures**: In the last decade, the computing world saw a progressive improvement on one side in the **computational capability of embedded boards**, and on another the increase of the \textbf{availability of cheap cloud computing power}. This means that a lot of available computational power is not available anymore on a **network of general purpose computers connected by local Ethernet network**, but the computational nodes available to use include on the collocated side \textbf{the network of embedded boards interconnected a real-time fieldbus} that are inside the robot, and on the remote side \textbf{any possible available type of server machine that can run as part of the cloud}. 
* **C3: Support for Full Introspection**: while the concept of **data hiding** and **encapsulation** behind common **standardized interfaces** popularized by **object-oriented programming**  is still an important aspect to enable re-usability and thus solving **Challenge C1**, for several use cases in robotics is important to also have **full access to the state of the software component that is running**, and to have the possibility to specify its **parameters in a structured way**.
* **C4: Open Science and Software Reproducibility**: While the rest of challenges are more related to specific **functional requirements**, for research in robotics it is important to make sure to use tools that ensure **reproducibility of results** obtained with that sofware, so that that researchers outside of the original team that performed the result can **validate** the results, to respect one of the fundamental principles of the **scientific method**~\citeother{Baker2016}. The obstacles to software reproducibility are many, and include the use of \textbf{non-deterministic simulation software}, the use of tools that complicate the process of getting \textbf{precise version information of the software} used for an experiment or the use of \textbf{closed source tools} that are not easily obtainable.  

## Existing Solutions 

The approach that are currently used in software development for robotics research are various. While the most successful model in the enterprise world is the use of **commercial and monolithic Model-Based Engineering (MBE) tools such as MATLAB/Simulink or Dymola}, in the academic research world is common to  \textbf{manually decompose} the functionality of a system in different **"software components"** that communicate with each other with patterns such as **Publishâ€“Subscribe** pattern or **Observer pattern** using **open source frameworks such as ROS, ROS2 or YARP**. Thanks to the abstraction provided by these middlewares, software components can be implemented in different programming languages, implementing in \textbf{efficient programming languages such as C++} only the one that actually require real time performances, and using more **user-friendly programming languages such as Python** the other components. 

While historically robotic middleware have been promoted with the precise goal of addressing the **Challenge C1**, in practice as of late 2020, the implementations of these middleware require that software components need either \textbf{network sockets} or \textbf{threads} to be run, and so they cannot be used in simulation environments that do not have access to **system-level resources**. Furthermore, this requirements typically prevent the use of software components that use middleware abstractions in \textbf{massively parallel simulations} in the same system, unless computationally and resource expensive virtualization techniques are used.  

Furthermore, while most existing robotic middleware aim for **distributing computations** across  machines with fully fledged operating system such as Linux or Windows connected by local Ethernet networks, they do not focus in distributing computations across 
**embedded boards** with no operating system at all (bare metal) or with lightweight Real-Time Operating Systems (RTOS), or across **cloud servers**, complicating their use for addressing \textbf{Challenge C2}.

Regarding **Challenge C3**, while robotic research middleware provided means to address the goal of **structured access to software parameters**, they never promoted at all any facility to expose the \textbf{internal state} of their software components. For this reason the common recommendation to robotics software developers is to always decompose their code software in \textbf{middleware-agnostic libraries}, and then write \textbf{robotics middleware components} on the top of this middleware-agnostic libraries. However, while this pattern is a successful model to maximize reuse of software across different middelware as in **Challenge C1**, making sure that the **state of the computation is fully available**, and not hidden behind **private or not accessible structures** requires typically an extreme care and insight from the library developer, and accessing the state of of each different middleware-agnostic library require ad-hoc **glue code** for each library, that prevents the easy access to the state, even if it is available.

Regarding **Challenge C4**, a great achievement of open source middleware in robotics has been to actively promote the use of **free and open source software in robotics research}, simplifying the reproducibility of robotics research results. However, several facilities and tools provided by the currently available robotics middleware can introduce **unnecessary non-determinism**, especially when they force the use of \textbf{network interfaces} or \textbf{threads} to execute the software components.  

## Technological Trends to Exploit to Address the Challenges

In my opinion, it is not useful to  search for a **silver bullet** of robotics research software, a single action or "new software or middleware" that addresses all this challenges. Even if such \textbf{project in theory existed}, creating a completely new  technology that covers all the possible use cases, convincing existing users to adopt it and maintaining it would be a **nearly impossible task** even for an whole organization only devoted to that. 

At the contrary, in my opinion the **only realistic path** to solve these challenges is to take \textbf{relevant technologies} from different fields, even technologies that are not currently used in the robotics field, and \textbf{validating them} in concrete research and development use cases and scenarios related to robotics, extending them if limitations are found.  

Among the technologies that could be useful and that I intend to investigate as part of my research, it is worth mentioning the following:
* The **Functional Mockup Interface (FMI)** is a ``free standard that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file''~\citeother{blockwitz2012functional}. It has been widely adopted for \textbf{simulation} purposes in the \textbf{automotive sector}. It supports exposing the complete state of a software component (addressing \textbf{Challenge C3}), and it is already supported natively by more then 150+ tools (\textbf{Challenge C1}). Regarding \textbf{Challenge C2} research effort is currently undergoing to ensure that it can be used also to represent controllers that can directly run on **embedded boards** (so-called Electronic control unit, ECU in the automotive jargon), as part of the \textbf{eFMI (embedded FMI) standard} being developed in EMPHYSIS ITEA3 project~\citeother{emphysis}. Preliminary examples of integration of FMI with the robotics scientific software stack I worked on can be found in \citemine{lange2021fmiros}. From the \textbf{technology transfer} point of view, ensuring that robotics software is compatible out of the box with the FMI standard will permit to easily bring robotics research results to the \textbf{automotive sector}, including applications related to \textbf{autonomous driving}. 
* **OPC UA FLC**~\citeother{opcuaflc} is the next-generation \textbf{deterministic} fieldbus system on which the vast majority of \textbf{automation software} companies are working on and that is intended to complement and eventually replace fieldbus technologies such as EtherCAT, DeviceNet and CANOpen. This fieldbus technologies are of common use as of 2020 to implement the \textbf{communication between the central processing unit of robots and their distribute embedded control boards}. Ensuring that \textbf{research robotics software} developed in the future can be transparently distributed over a network of OPC UA FLC-connected devices will both ensure that the software can be deployed easily in the embedded boards of the robots of the future (\textbf{Challenge C2}) with \textbf{deterministic} communication time  (\textbf{Challenge C4}) , and that it can be also easily brought to industrial application in the **industrial automation** sector.
* Classical robotics middleware such as **YARP** or **ROS2** have a huge advantage over any possible competing approach for \textbf{writing robotics research software} has they are already well know and accepted by the robotics research community. Rather then try to change how \textbf{robotics researchers already know and are trained to write code}, a much more effective path to address our challenges is to \textbf{influence the evolution} of the design of middleware abstractions, such as \textbf{ROS2 nodes} or \textbf{YARP devices}, to ensure that if needed they can be used in a way in which the full state of the component is available (\textbf{Challenge C3}) or that they can run on a embedded board (\textbf{Challenge C2}). Examples are ensuring that a \textbf{YARP device} or \textbf{ROS2 node} can be wrapped in a \textbf{FMI block} so that it can be loaded in **MATLAB** or \textbf{Simulink}, or ensure that they can be easily  cross-compiled for a given network-less and thread-less architecture so that it can be easily run in a bare-metal embedded board.
* Sofware packaging tools such as **conda**~\citeother{conda} or **spack**~\citeother{spack} and distributions such as **conda-forge**~\citeother{condaforge} and **E4S**~\citeother{e4s}. One of the main limiting factors of some of the existing efforts in bringing **Model Based Engineering tools** in robotics research, such as the software developed as part of \textbf{RobMoSys european project}~\citeother{Gerard2010,Lotz2014}  is that most of the software is available only in **source code** or in **ad-hoc binary**, making it challenging to **systematically install them** together with other software tools. Technologies such as \textbf{virtual machines} or \textbf{containers such as Docker or Singularity} can be useful to use or test a single tool, but they are not useful in simplify the \textbf{combined use of software coming from multiple sources}. What already proved instead \textbf{extremely effective in other fields} such as Bioinformatics~\citeother{Gruning2018}, High Performance Computing (HPC)~\citeother{spack} and High Energy Physics (HEP)~\citeother{burr2019sustainable} is the use of open source multi-platform package manager tools such as \textbf{conda}~\citeother{conda} or \textbf{spack}~\citeother{spack} and community curated distributions of software such as \textbf{conda-forge}~\citeother{condaforge} or \textbf{E4S}~\citeother{e4s}. These tools permit to drastically simplify the build and installation of large collection of interdependent scientific software (the so-called \textbf{scientific software task}) in a multi-platform way, simplifying software reuse and in this way helping addressing \textbf{Challenge C1}. This technology can be used in general to make sure that any tool developed can be easily usable with no installation barrier, and more in particular can also be of help in addressing \textbf{Challenge C4}, as most of this package managers also provide support to easily obtain the \textbf{exact version} of the software used for each scientific experiment. 
